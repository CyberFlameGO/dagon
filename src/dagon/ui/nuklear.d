/*
Copyright (c) 2019 Mateusz Muszy≈Ñski

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module dagon.ui.nuklear;

import core.stdc.stdio;
import std.stdio;

import dlib.core.memory;
import dlib.core.stream;
import dlib.container.dict;
import dlib.container.queue;
import dlib.text.utf8;
import dlib.math.vector;
import dlib.image.color;

import dagon.core.interfaces;
import dagon.core.libs;
import dagon.core.ownership;
import dagon.core.event;
import dagon.core.keycodes;
import dagon.ui.font;
import dagon.graphics.rc;
import dagon.graphics.shaderloader;
import dagon.graphics.texture;

private extern(C) void clipboardPaste(nk_handle usr, nk_text_edit* edit)
{
    char* text = SDL_GetClipboardText();
    if (text) 
    {
        nk_textedit_paste(edit, text, nk_strlen(text));
        SDL_free(text);
    }
}

private extern(C) void clipboardCopy(nk_handle usr, const(char)* text, int len)
{
    import core.stdc.string;
    import core.stdc.stdlib;
    char *str = null;
    if (!len) return;
    str = cast(char*)malloc(cast(size_t)len+1);
    if (!str) return;
    memcpy(str, text, cast(size_t)len);
    str[len] = '\0';
    SDL_SetClipboardText(str);
    free(str);
}

enum NuklearEventType
{
    MouseMotion,
    MouseButton,
    MouseScroll,
    TextInput,
    Key
}

struct NuklearEvent
{
    NuklearEventType type;
    int x;
    int y;
    union
    {
        int button;
        dchar unicode;
        int key;
    }
    int down;
}

class NuklearGUI : Owner, Drawable
{
    alias nk_color Color;
    alias nk_colorf Colorf;
    alias nk_rect Rect;
    alias nk_rect Recti;
    alias nk_vec2 Vec2;
    alias nk_vec2i Vec2i;
    alias nk_cursor Cursor;

    NuklearEvent[10] events;
    int eventsCount = 0;

    nk_context ctx;
    nk_font_atlas atlas;
    nk_buffer cmds;
    nk_draw_null_texture nullTexture;

    GLuint vbo;
    GLuint vao;
    GLuint ebo;

    GLuint shaderProgram;
    GLuint vertexShader;
    GLuint fragmentShader;

    GLint positionLoc;
    GLint texcoordLoc;
    GLint colorLoc;

    GLint textureLoc;
    GLint projectionMatrixLoc;

    GLuint fontTexture;

    string vs = import("Nuklear.vs");
    string fs = import("Nuklear.fs");

    EventManager* eventManager; // Needed for mouse position

    this(EventManager* em, Owner o)
    {
        super(o);

        eventManager = em;

        nk_init_default(&ctx, null);

        ctx.clip.copy = cast(nk_plugin_copy)&clipboardCopy;
        ctx.clip.paste = cast(nk_plugin_paste)&clipboardPaste;
        ctx.clip.userdata = nk_handle_ptr(null);

        nk_buffer_init_default(&cmds);

        prepareVAO();

        nk_font_atlas_init_default(&atlas);
        nk_font_atlas_begin(&atlas);

        const(void) *image = null;
        int w = 0;
        int h = 0;
        image = nk_font_atlas_bake(&atlas, &w, &h, NK_FONT_ATLAS_RGBA32);

        glGenTextures(1, &fontTexture);
        glBindTexture(GL_TEXTURE_2D, fontTexture);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cast(GLsizei)w, cast(GLsizei)h, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);

        nk_font_atlas_end(&atlas, nk_handle_id(cast(int)fontTexture), &nullTexture);
        if (atlas.default_font)
            nk_style_set_font(&ctx, &atlas.default_font.handle);

        // TODO: add font loading
    }

    ~this()
    {
        nk_font_atlas_clear(&atlas);
        nk_free(&ctx);
        nk_buffer_free(&cmds);
        glDetachShader(shaderProgram, vertexShader);
        glDetachShader(shaderProgram, fragmentShader);
        glDeleteShader(vertexShader);
        glDeleteShader(fragmentShader);
        glDeleteProgram(shaderProgram);
        glDeleteTextures(1, &fontTexture);
        glDeleteBuffers(1, &vbo);
        glDeleteBuffers(1, &ebo);
    }

    void prepareVAO()
    {
        vertexShader = compileShader(vs, ShaderStage.vertex);
        fragmentShader = compileShader(fs, ShaderStage.fragment);
        if (vertexShader != 0 && fragmentShader != 0)
            shaderProgram = linkShaders(vertexShader, fragmentShader);

        if (shaderProgram != 0)
        {
            textureLoc = glGetUniformLocation(shaderProgram, "Texture");
            projectionMatrixLoc = glGetUniformLocation(shaderProgram, "ProjMtx");      
            positionLoc = glGetAttribLocation(shaderProgram, "va_Vertex");
            texcoordLoc = glGetAttribLocation(shaderProgram, "va_Texcoord");
            colorLoc = glGetAttribLocation(shaderProgram, "va_Color");
        }

        // buffer setup
        glGenBuffers(1, &vbo);
        glGenBuffers(1, &ebo);
        glGenVertexArrays(1, &vao);

        glBindVertexArray(vao);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);

        glEnableVertexAttribArray(positionLoc);
        glEnableVertexAttribArray(texcoordLoc);
        glEnableVertexAttribArray(colorLoc);

        glVertexAttribPointer(positionLoc, 2, GL_FLOAT, GL_FALSE, 20, cast(void*)0);
        glVertexAttribPointer(texcoordLoc, 2, GL_FLOAT, GL_FALSE, 20, cast(void*)8);
        glVertexAttribPointer(colorLoc, 4, GL_UNSIGNED_BYTE, GL_TRUE, 20, cast(void*)16);

        glBindTexture(GL_TEXTURE_2D, 0);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
    }

    override void update(double dt)
    {
        nk_input_begin(&ctx);
        nk_input_motion(&ctx, eventManager.mouseX, eventManager.mouseY);

        // perform all inputs
        while (eventsCount != 0)
        {
            auto e = events[--eventsCount];
            switch (e.type)
            {
                case NuklearEventType.Key:
                    nk_input_key(&ctx, cast(nk_keys)e.key, e.down);
                    break;
                case NuklearEventType.MouseButton:
                    nk_input_button(&ctx, cast(nk_buttons)e.button, e.x, e.y, e.down);
                    break;
                case NuklearEventType.MouseScroll:
                    nk_input_scroll(&ctx, nk_vec2(e.x, e.y));
                    break;
                case NuklearEventType.TextInput:
                    nk_input_unicode(&ctx, e.unicode);
                    break;
                default:
                    break;
            }
        }

        nk_input_end(&ctx);
    }

    override void render(RenderingContext* rc)
    {
        const(int) maxVertexBuffer = 512 * 1024;
        const(int) maxElementBuffer = 128 * 1024;

        glEnable(GL_SCISSOR_TEST);
        glEnable(GL_BLEND);
        glBlendEquation(GL_FUNC_ADD);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glActiveTexture(GL_TEXTURE0);

        glUseProgram(shaderProgram);
        glUniform1i(textureLoc, 0);
        glUniformMatrix4fv(projectionMatrixLoc, 1, GL_FALSE, rc.projectionMatrix.arrayof.ptr);

        const(nk_draw_command) *cmd;
        void *vertices;
        void *elements;
        const(nk_draw_index) *offset = null;
        nk_buffer vbuf;
        nk_buffer ebuf;

        // allocate vertex and element buffer
        glBindVertexArray(vao);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);

        glBufferData(GL_ARRAY_BUFFER, maxVertexBuffer, null, GL_STREAM_DRAW);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, maxElementBuffer, null, GL_STREAM_DRAW);

        // load vertices/elements directly into vertex/element buffer
        vertices = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
        elements = glMapBuffer(GL_ELEMENT_ARRAY_BUFFER, GL_WRITE_ONLY);
        {
            // fill convert configuration 
            nk_convert_config config;
            nk_draw_vertex_layout_element[] vertex_layout = 
            [
                { NK_VERTEX_POSITION, NK_FORMAT_FLOAT, 0 },
                    { NK_VERTEX_TEXCOORD,  NK_FORMAT_FLOAT, 8 },
                        { NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, 16 },
                            NK_VERTEX_LAYOUT_END
            ];
            config.vertex_layout = vertex_layout.ptr;
            config.vertex_size = 20;
            config.vertex_alignment = 0;
            config.null_ = nullTexture;
            config.circle_segment_count = 16;
            config.curve_segment_count = 16;
            config.arc_segment_count = 16;
            config.global_alpha = 1.0f;
            config.shape_AA = NK_ANTI_ALIASING_ON;
            config.line_AA = NK_ANTI_ALIASING_ON;

            // setup buffers to load vertices and elements
            nk_buffer_init_fixed(&vbuf, vertices, cast(nk_size)maxVertexBuffer);
            nk_buffer_init_fixed(&ebuf, elements, cast(nk_size)maxElementBuffer);
            nk_convert(&ctx, &cmds, &vbuf, &ebuf, &config);
        }
        glUnmapBuffer(GL_ARRAY_BUFFER);
        glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER);

        // iterate over and execute each draw command
        nk_draw_foreach(&ctx, &cmds, (cmd)
                        {
                            if (!cmd.elem_count) return;
                            glBindTexture(GL_TEXTURE_2D, cmd.texture.id);
                            glScissor(cast(GLint)(cmd.clip_rect.x),
                                      cast(GLint)((eventManager.windowHeight - cast(GLint)(cmd.clip_rect.y + cmd.clip_rect.h))),
                                      cast(GLint)(cmd.clip_rect.w),
                                      cast(GLint)(cmd.clip_rect.h));
                            glDrawElements(GL_TRIANGLES, cmd.elem_count, GL_UNSIGNED_INT, offset);
                            offset += cmd.elem_count;
                        });
        nk_clear(&ctx);

        glDisable(GL_BLEND);
        glDisable(GL_SCISSOR_TEST);
    }

    void inputKey(nk_keys key, int down)
    {
        auto e = NuklearEvent(NuklearEventType.Key);
        e.key = key;
        e.down = down;
        if (eventsCount < 10)
            events[eventsCount++] = e;
    }

    void inputKeyDown(nk_keys key)
    {
        inputKey(key, 1);
    }

    void inputKeyUp(nk_keys key)
    {
        inputKey(key, 0);
    }

    void inputButton(int button, int down)
    {
        auto e = NuklearEvent(NuklearEventType.MouseButton);
        switch (button)
        {
            case MB_LEFT: e.button = nk_buttons.NK_BUTTON_LEFT; break;
            case MB_MIDDLE: e.button = nk_buttons.NK_BUTTON_MIDDLE; break;
            case MB_RIGHT: e.button = nk_buttons.NK_BUTTON_RIGHT; break;
            default:
                break;
        }
        e.x = eventManager.mouseX;
        e.y = eventManager.mouseY;
        e.down = down;
        if (eventsCount < 10)
            events[eventsCount++] = e;
    }

    void inputButtonDown(int button)
    {
        inputButton(button, 1);
    }

    void inputButtonUp(int button)
    {
        inputButton(button, 0);
    }

    void inputScroll(int x, int y)
    {
        auto e = NuklearEvent(NuklearEventType.MouseScroll);
        e.x = x;
        e.y = y;
        if (eventsCount < 10)
            events[eventsCount++] = e;
    }

    void inputUnicode(dchar key)
    {
        auto e = NuklearEvent(NuklearEventType.TextInput);
        e.unicode = key;
        if (eventsCount < 10)
            events[eventsCount++] = e;
    }

    void setUserData(nk_handle handle)
    {
        nk_set_user_data(&ctx, handle);
    }

    int begin(const(char)* title, nk_rect bounds, nk_flags flags)
    {
        return nk_begin(&ctx, title, bounds, flags);
    }

    int beginTitled(const(char)* name, const(char)* title, nk_rect bounds, nk_flags flags)
    {
        return nk_begin_titled(&ctx, name, title, bounds, flags);
    }

    void end()
    {
        nk_end(&ctx);
    }

    nk_window* windowFind(const(char)* name)
    {
        return nk_window_find(&ctx, name);
    }

    nk_panel* windowGetPanel()
    {
        return nk_window_get_panel(&ctx);
    }

    nk_rect windowGetContentRegion()
    {
        return nk_window_get_content_region(&ctx);
    }

    nk_vec2 windowGetContentRegionMin()
    {
        return nk_window_get_content_region_min(&ctx);
    }

    nk_vec2 windowGetContentRegionMax()
    {
        return nk_window_get_content_region_max(&ctx);
    }

    nk_vec2 windowGetContentRegionSize()
    {
        return nk_window_get_content_region_size(&ctx);
    }

    nk_command_buffer* windowGetCanvas()
    {
        return nk_window_get_canvas(&ctx);
    }

    int windowIsHovered()
    {
        return nk_window_is_hovered(&ctx);
    }

    int windowIsCollapsed(const(char)* name)
    {
        return nk_window_is_collapsed(&ctx, name);
    }

    int windowIsClosed(const(char)* name)
    {
        return nk_window_is_closed(&ctx,  name);
    }

    int windowIsHidden(const(char)* name)
    {
        return nk_window_is_hidden(&ctx,  name);
    }

    int windowIsActive(const(char)* name)
    {
        return nk_window_is_active(&ctx, name);
    }

    int windowIsAnyHovered()
    {
        return nk_window_is_any_hovered(&ctx);
    }

    int itemIsAnyActive()
    {
        return nk_item_is_any_active(&ctx);
    }

    void windowSetBounds(const(char)* name, nk_rect bounds)
    {
        nk_window_set_bounds(&ctx, name, bounds);
    }

    void windowSetPosition(const(char)* name, nk_vec2 pos)
    {
        nk_window_set_position(&ctx, name, pos);
    }

    void windowSetSize(const(char)* name, nk_vec2 size)
    {
        nk_window_set_size(&ctx, name, size);
    }

    void windowSetFocus(const(char)* name)
    {
        nk_window_set_focus(&ctx, name);
    }

    void windowClose(const(char)* name)
    {
        nk_window_close(&ctx, name);
    }

    void windowCollapse(const(char)* name, nk_collapse_states state)
    {
        nk_window_collapse(&ctx, name, state);
    }

    void windowCollapseIf(const(char)* name, nk_collapse_states state, int cond)
    {
        nk_window_collapse_if (&ctx, name, state, cond);
    }

    void windowShow(const(char)* name, nk_show_states state)
    {
        nk_window_show(&ctx, name, state);
    }

    void windowShowIf(const(char)* name, nk_show_states state, int cond)
    {
        nk_window_show_if (&ctx, name, state, cond);
    }

    void layoutSetMinRowHeight(float height)
    {
        nk_layout_set_min_row_height(&ctx, height);
    }

    void layoutResetMinRowHeight()
    {
        nk_layout_reset_min_row_height(&ctx);
    }

    nk_rect layoutWidgetBounds()
    {
        return nk_layout_widget_bounds(&ctx);
    }

    float layoutRatioFromPixel(float pixel_width)
    {
        return nk_layout_ratio_from_pixel(&ctx, pixel_width);
    }

    void layoutRowDynamic(float height, int cols)
    {
        nk_layout_row_dynamic(&ctx, height, cols);
    }

    void layoutRowStatic(float height, int item_width, int cols)
    {
        nk_layout_row_static(&ctx, height, item_width, cols);
    }

    void layoutRowBegin(nk_layout_format fmt, float row_height, int cols)
    {
        nk_layout_row_begin(&ctx, fmt, row_height, cols);
    }

    void layoutRowPush(float value)
    {
        nk_layout_row_push(&ctx, value);
    }

    void layoutRowEnd()
    {
        nk_layout_row_end(&ctx);
    }

    void layoutRow(nk_layout_format format, float height, int cols, const(float)* ratio)
    {
        nk_layout_row(&ctx, format, height, cols, ratio);
    }

    void layoutRowTemplateBegin(float row_height)
    {
        nk_layout_row_template_begin(&ctx, row_height);
    }

    void layoutRowTemplatePushDynamic()
    {
        nk_layout_row_template_push_dynamic(&ctx);
    }

    void layoutRowTemplatePushVariable(float min_width)
    {
        nk_layout_row_template_push_variable(&ctx, min_width);
    }

    void layoutRowTemplatePushStatic(float width)
    {
        nk_layout_row_template_push_static(&ctx, width);
    }

    void layoutRowTemplateEnd()
    {
        nk_layout_row_template_end(&ctx);
    }

    void layoutSpaceBegin(nk_layout_format foramt, float height, int widget_count)
    {
        nk_layout_space_begin(&ctx, foramt, height, widget_count);
    }

    void layoutSpacePush(nk_rect bounds)
    {
        nk_layout_space_push(&ctx, bounds);
    }

    void layoutSpaceEnd()
    {
        nk_layout_space_end(&ctx);
    }

    nk_rect layoutSpaceBounds()
    {
        return nk_layout_space_bounds(&ctx);
    }

    nk_vec2 layoutSpaceToScreen(nk_vec2 a)
    {
        return nk_layout_space_to_screen(&ctx, a);
    }

    nk_vec2 layoutSpaceToLocal(nk_vec2 a)
    {
        return nk_layout_space_to_local(&ctx, a);
    }

    nk_rect layoutSpaceRectToScreen(nk_rect a)
    {
        return nk_layout_space_rect_to_screen(&ctx, a);
    }

    nk_rect layoutSpaceRectToLocal(nk_rect a)
    {
        return nk_layout_space_rect_to_local(&ctx, a);
    }

    int groupBegin(const(char)* title, nk_flags flags)
    {
        return nk_group_begin(&ctx, title, flags);
    }

    int groupBeginTitled(const(char)* name, const(char)* title, nk_flags flags)
    {
        return nk_group_begin_titled(&ctx, name, title, flags);
    }

    void groupEnd()
    {
        nk_group_end(&ctx);
    }

    int groupScrolledOffsetBegin(nk_uint* x_offset, nk_uint* y_offset, const(char)* title, nk_flags flags)
    {
        return nk_group_scrolled_offset_begin(&ctx, x_offset, y_offset, title, flags);
    }

    int groupScrolledBegin(nk_scroll* off, const(char)* title, nk_flags flags)
    {
        return nk_group_scrolled_begin(&ctx, off, title, flags);
    }

    void groupScrolledEnd()
    {
        nk_group_scrolled_end(&ctx);
    }

    int treePush(size_t line = __LINE__)(nk_context *ctx, nk_tree_type type, const(char) *title, nk_collapse_states state)
    {
        return nk_tree_push_hashed(ctx, type, title, state, null, 0, line);
    }

    int treePushId(nk_context *ctx, nk_tree_type type, const(char) *title, nk_collapse_states state, int id)
    {
        return nk_tree_push_hashed(ctx, type, title, state, null, 0, id);
    }

    void treePop()
    {
        nk_tree_pop(&ctx);
    }

    int treeStatePush(nk_tree_type type, const(char)* title, nk_collapse_states* state)
    {
        return nk_tree_state_push(&ctx, type, title, state);
    }

    int treeStateImagePush(nk_tree_type type, nk_image image, const(char)* title, nk_collapse_states* state)
    {
        return nk_tree_state_image_push(&ctx, type, image, title, state);
    }

    void treeStatePop()
    {
        nk_tree_state_pop(&ctx);
    }

    auto treeElementPush(size_t line = __LINE__)(nk_context *ctx, nk_tree_type type, const(char) *title, nk_collapse_states state, int* selected)
    {
        return nk_tree_element_push_hashed(ctx, type, title, state, selected, null, 0, line);
    }

    auto treeElementPushId(nk_context *ctx, nk_tree_type type, const(char) *title, nk_collapse_states state, int* selected, int id)
    {
        return nk_tree_element_push_hashed(ctx, type, title, state, selected, null, 0, id);
    }

    auto treeElementImagePush(size_t line = __LINE__)(nk_context *ctx, nk_tree_type type, nk_image img, const(char) *title, nk_collapse_states state)
    {
        return nk_tree_image_push_hashed(ctx, type, img, title, state, null,0, line);
    }

    auto treeElementImagePushId(nk_context *ctx, nk_tree_type type, nk_image img, const(char) *title, nk_collapse_states state, int id)
    {
        return nk_tree_image_push_hashed(ctx, type, img, title, state, null, 0, id);
    }

    void treeElementPop()
    {
        nk_tree_element_pop(&ctx);
    }

    int listViewBegin(nk_list_view* out_, const(char)* id, nk_flags flags, int row_height, int row_count)
    {
        return nk_list_view_begin(&ctx, out_, id, flags, row_height, row_count);
    }

    nk_rect widgetBounds()
    {
        return nk_widget_bounds(&ctx);
    }

    nk_vec2 widgetPosition()
    {
        return nk_widget_position(&ctx);
    }

    nk_vec2 widgetSize()
    {
        return nk_widget_size(&ctx);
    }

    float widgetWidth()
    {
        return nk_widget_width(&ctx);
    }

    float widgetHeight()
    {
        return nk_widget_height(&ctx);
    }

    int widgetIsHovered()
    {
        return nk_widget_is_hovered(&ctx);
    }

    int widgetIsMouseClicked(nk_buttons buttons)
    {
        return nk_widget_is_mouse_clicked(&ctx, buttons);
    }

    int widgetHasMouseClickDown(nk_buttons buttons, int down)
    {
        return nk_widget_has_mouse_click_down(&ctx, buttons, down);
    }

    void spacing(int cols)
    {
        nk_spacing(&ctx, cols);
    }

    void text(const(char)* txt, int len, nk_flags flags)
    {
        nk_text(&ctx, txt, len, flags);
    }

    void textColored(const(char)* txt, int len, nk_flags flags, nk_color color)
    {
        nk_text_colored(&ctx, txt, len, flags, color);
    }

    void textWrap(const(char)* txt, int len)
    {
        nk_text_wrap(&ctx, txt, len);
    }

    void textWrapColored(const(char)* txt, int len, nk_color color)
    {
        nk_text_wrap_colored(&ctx, txt, len, color);
    }

    void label(const(char)* txt, nk_flags align__)
    {
        nk_label(&ctx, txt, align__);
    }

    void labelColored(const(char)* txt, nk_flags align__, nk_color color)
    {
        nk_label_colored(&ctx, txt, align__, color);
    }

    void labelWrap(const(char)* txt)
    {
        nk_label_wrap(&ctx, txt);
    }

    void labelColoredWrap(const(char)* txt, nk_color color)
    {
        nk_label_colored_wrap(&ctx, txt, color);
    }

    void image(nk_image img)
    {
        nk_image_(&ctx, img);
    }

    void imageColor(nk_image img, nk_color color)
    {
        nk_image_color(&ctx, img, color);
    }

    /*void labelf(nk_flags, const(char)*, ...)
    {
    nk_labelf(&ctx);
    }

    void labelfColored(nk_flags, nk_color, const(char)*, ...)
    {
    nk_labelf_colored(&ctx);
    }

    void labelfWrap(const(char)*, ...)
    {
    nk_labelf_wrap(&ctx);
    }

    void labelfColoredWrap(nk_color, const(char)*, ...)
    {
    nk_labelf_colored_wrap(&ctx);
    }

    void labelfv(nk_flags, const(char)*, va_list)
    {
    nk_labelfv(&ctx);
    }

    void labelfvColored(nk_flags, nk_color, const(char)*, va_list)
    {
    nk_labelfv_colored(&ctx);
    }

    void labelfvWrap(const(char)*, va_list)
    {
    nk_labelfv_wrap(&ctx);
    }

    void labelfvColoredWrap(nk_color, const(char)*, va_list)
    {
    nk_labelfv_colored_wrap(&ctx);
    }
    */
    void valueBool(const(char)* prefix, int value)
    {
        nk_value_bool(&ctx, prefix, value);
    }

    void valueInt(const(char)* prefix, int value)
    {
        nk_value_int(&ctx, prefix, value);
    }

    void valueUint(const(char)* prefix, uint value)
    {
        nk_value_uint(&ctx, prefix, value);
    }

    void valueFloat(const(char)* prefix, float value)
    {
        nk_value_float(&ctx, prefix, value);
    }

    void valueColorByte(const(char)* prefix, nk_color value)
    {
        nk_value_color_byte(&ctx, prefix, value);
    }

    void valueColorFloat(const(char)* prefix, nk_color value)
    {
        nk_value_color_float(&ctx, prefix, value);
    }

    void valueColorHex(const(char)* prefix, nk_color value)
    {
        nk_value_color_hex(&ctx, prefix, value);
    }

    int buttonText(const(char)* title, int len)
    {
        return nk_button_text(&ctx, title, len);
    }

    int buttonLabel(const(char)* title)
    {
        return nk_button_label(&ctx, title);
    }

    int buttonColor(nk_color color)
    {
        return nk_button_color(&ctx,  color);
    }

    int buttonSymbol(nk_symbol_type type)
    {
        return nk_button_symbol(&ctx, type);
    }

    int buttonImage(nk_image img)
    {
        return nk_button_image(&ctx, img);
    }

    int buttonSymbolLabel(nk_symbol_type type, const(char)* label, nk_flags text_alignment)
    {
        return nk_button_symbol_label(&ctx, type, label, text_alignment);
    }

    int buttonSymbolText(nk_symbol_type type, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_button_symbol_text(&ctx, type, txt, len, align_ment);
    }

    int buttonImageLabel(nk_image img, const(char)* txt, nk_flags text_alignment)
    {
        return nk_button_image_label(&ctx, img, txt, text_alignment);
    }

    int buttonImageText(nk_image img, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_button_image_text(&ctx, img, txt, len, align_ment);
    }

    int buttonTextStyled(const(nk_style_button)* style, const(char)* title, int len)
    {
        return nk_button_text_styled(&ctx, style, title, len);
    }

    int buttonLabelStyled(const(nk_style_button)* style, const(char)* title)
    {
        return nk_button_label_styled(&ctx, style, title);
    }

    int buttonSymbolStyled(const(nk_style_button)* style, nk_symbol_type type)
    {
        return nk_button_symbol_styled(&ctx, style, type);
    }

    int buttonImageStyled(const(nk_style_button)* style, nk_image img)
    {
        return nk_button_image_styled(&ctx, style, img);
    }

    int buttonSymbolTextStyled(const(nk_style_button)* style, nk_symbol_type type, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_button_symbol_text_styled(&ctx, style, type, txt, len, align_ment);
    }

    int buttonSymbolLabelStyled(const(nk_style_button)* style, nk_symbol_type symbol, const(char)* title, nk_flags align_)
    {
        return nk_button_symbol_label_styled(&ctx, style, symbol, title, align_);
    }

    int buttonImageLabelStyled(const(nk_style_button)* style, nk_image img, const(char)* label, nk_flags text_alignment)
    {
        return nk_button_image_label_styled(&ctx, style, img, label, text_alignment);
    }

    int buttonImageTextStyled(const(nk_style_button)* style, nk_image img, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_button_image_text_styled(&ctx, style, img, txt, len, align_ment);
    }

    void buttonSetBehavior(nk_button_behavior beh)
    {
        nk_button_set_behavior(&ctx, beh);
    }

    int buttonPushBehavior(nk_button_behavior beh)
    {
        return nk_button_push_behavior(&ctx, beh);
    }

    int buttonPopBehavior()
    {
        return nk_button_pop_behavior(&ctx);
    }

    int checkLabel(const(char)* label, int active)
    {
        return nk_check_label(&ctx, label, active);
    }

    int checkText(const(char)* txt, int len, int active)
    {
        return nk_check_text(&ctx, txt, len, active);
    }

    uint checkFlagsLabel(const(char)* label, uint flags, uint value)
    {
        return nk_check_flags_label(&ctx, label, flags, value);
    }

    uint checkFlagsText(const(char)* txt, int len, uint flags, uint value)
    {
        return nk_check_flags_text(&ctx, txt, len, flags, value);
    }

    int checkboxLabel(const(char)* label, int* active)
    {
        return nk_checkbox_label(&ctx, label, active);
    }

    int checkboxText(const(char)* txt, int len, int* active)
    {
        return nk_checkbox_text(&ctx, txt, len, active);
    }

    int checkboxFlagsLabel(const(char)* label, uint* flags, uint value)
    {
        return nk_checkbox_flags_label(&ctx, label, flags, value);
    }

    int checkboxFlagsText(const(char)* txt, int len, uint* flags, uint value)
    {
        return nk_checkbox_flags_text(&ctx, txt, len, flags, value);
    }

    int radioLabel(const(char)* label, int* active)
    {
        return nk_radio_label(&ctx, label, active);
    }

    int radioText(const(char)* txt, int len, int* active)
    {
        return nk_radio_text(&ctx, txt, len, active);
    }

    int optionLabel(const(char)* label, int active)
    {
        return nk_option_label(&ctx, label, active);
    }

    int optionText(const(char)* txt, int len, int active)
    {
        return nk_option_text(&ctx, txt, len, active);
    }

    int selectableLabel(const(char)* label, nk_flags align_, int* value)
    {
        return nk_selectable_label(&ctx, label, align_, value);
    }

    int selectableText(const(char)* txt, int len, nk_flags align_, int* value)
    {
        return nk_selectable_text(&ctx, txt, len, align_, value);
    }

    int selectableImageLabel(nk_image img, const(char)* label, nk_flags align_, int* value)
    {
        return nk_selectable_image_label(&ctx, img, label, align_, value);
    }

    int selectableImageText(nk_image img, const(char)* text, int len, nk_flags align_, int* value)
    {
        return nk_selectable_image_text(&ctx, img, text, len, align_, value);
    }

    int selectableSymbolLabel(nk_symbol_type type, const(char)* label, nk_flags align_, int* value)
    {
        return nk_selectable_symbol_label(&ctx, type, label, align_, value);
    }

    int selectableSymbolText(nk_symbol_type type, const(char)* txt, int len, nk_flags align_, int* value)
    {
        return nk_selectable_symbol_text(&ctx, type, txt, len, align_, value);
    }

    int selectLabel(const(char)* label, nk_flags align_, int value)
    {
        return nk_select_label(&ctx, label, align_, value);
    }

    int selectText(const(char)* txt, int len, nk_flags align_, int value)
    {
        return nk_select_text(&ctx, txt, len, align_, value);
    }

    int selectImageLabel(nk_image img, const(char)* label, nk_flags align_, int value)
    {
        return nk_select_image_label(&ctx, img, label, align_, value);
    }

    int selectImageText(nk_image img, const(char)* txt, int len, nk_flags align_, int value)
    {
        return nk_select_image_text(&ctx, img, txt, len, align_, value);
    }

    int selectSymbolLabel(nk_symbol_type type, const(char)* label, nk_flags align_, int value)
    {
        return nk_select_symbol_label(&ctx, type, label, align_, value);
    }

    int selectSymbolText(nk_symbol_type type, const(char)* txt, int len, nk_flags align_, int value)
    {
        return nk_select_symbol_text(&ctx, type, txt, len, align_, value);
    }

    float slide(float min, float val, float max, float step)
    {
        return nk_slide_float(&ctx,min, val, max, step);
    }

    int slide(int min, int val, int max, int step)
    {
        return nk_slide_int(&ctx,min, val, max, step);
    }

    int slider(float min, float* val, float max, float step)
    {
        return nk_slider_float(&ctx, min, val, max, step);
    }

    int slider(int min, int* val, int max, int step)
    {
        return nk_slider_int(&ctx, min, val, max, step);
    }

    int progress(nk_size* cur, nk_size max, int modifyable)
    {
        return nk_progress(&ctx, cur, max, modifyable);
    }

    nk_size prog(nk_size cur, nk_size max, int modifyable)
    {
        return nk_prog(&ctx, cur, max, modifyable);
    }

    nk_colorf colorPicker(nk_colorf color, nk_color_format format)
    {
        return nk_color_picker(&ctx, color, format);
    }

    Color4f colorPicker(Color4f color, nk_color_format format)
    {   
        nk_colorf tmp = nk_colorf(color.r, color.g, color.b, color.a);
        tmp = nk_color_picker(&ctx, tmp, format);
        return Color4f(tmp.r, tmp.g, tmp.b, tmp.a);
    }

    int colorPick(nk_colorf* color, nk_color_format format)
    {
        return nk_color_pick(&ctx, color, format);
    }

    int colorPick(Color4f* color, nk_color_format format)
    {
        nk_colorf tmp = nk_colorf(color.r, color.g, color.b, color.a);
        int res = nk_color_pick(&ctx, &tmp, format);
        *color = Color4f(tmp.r, tmp.g, tmp.b, tmp.a);
        return res;
    }

    void property(const(char)* name, int min, int* val, int max, int step, float inc_per_pixel)
    {
        nk_property_int(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    void property(const(char)* name, float min, float* val, float max, float step, float inc_per_pixel)
    {
        nk_property_float(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    void property(const(char)* name, double min, double* val, double max, double step, float inc_per_pixel)
    {
        nk_property_double(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    int property(const(char)* name, int min, int val, int max, int step, float inc_per_pixel)
    {
        return nk_propertyi(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    float property(const(char)* name, float min, float val, float max, float step, float inc_per_pixel)
    {
        return nk_propertyf(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    double property(const(char)* name, double min, double val, double max, double step, float inc_per_pixel)
    {
        return nk_propertyd(&ctx, name, min, val, max, step, inc_per_pixel);
    }


    nk_flags editString(nk_flags flags, char* buffer, int* len, int max, nk_plugin_filter filter)
    {
        return nk_edit_string(&ctx, flags, buffer, len, max, filter);
    }

    nk_flags editStringZeroTerminated(nk_flags flags, char* buffer, int max, nk_plugin_filter filter)
    {
        return nk_edit_string_zero_terminated(&ctx, flags, buffer, max, filter);
    }

    nk_flags editBuffer(nk_flags flags, nk_text_edit* edit, nk_plugin_filter filter)
    {
        return nk_edit_buffer(&ctx, flags, edit, filter);
    }

    void editFocus(nk_flags flags)
    {
        nk_edit_focus(&ctx, flags);
    }

    void editUnfocus()
    {
        nk_edit_unfocus(&ctx);
    }

    int chartBegin(nk_chart_type type, int num, float min, float max)
    {
        return nk_chart_begin(&ctx, type, num, min, max);
    }

    int chartBeginColored(nk_chart_type type, nk_color color, nk_color active, int num, float min, float max)
    {
        return nk_chart_begin_colored(&ctx, type, color, active, num, min, max);
    }

    void chartAddSlot(const(nk_chart_type) type, int count, float min_value, float max_value)
    {
        nk_chart_add_slot(&ctx, type, count, min_value, max_value);
    }

    void chartAddSlotColored(const(nk_chart_type) type, nk_color color, nk_color active, int count, float min_value, float max_value)
    {
        nk_chart_add_slot_colored(&ctx, type, color, active, count, min_value, max_value);
    }

    nk_flags chartPush(float value)
    {
        return nk_chart_push(&ctx, value);
    }

    nk_flags chartPushSlot(float value, int slot)
    {
        return nk_chart_push_slot(&ctx, value, slot);
    }

    void chartEnd()
    {
        nk_chart_end(&ctx);
    }

    void plot(nk_chart_type type, const(float)* values, int count, int offset)
    {
        nk_plot(&ctx, type, values, count, offset);
    }

    void plotFunction(nk_chart_type type, float function(int index) fn, int count, int offset)
    {
        import std.algorithm : min, max;
        int i = 0;
        float min_value;
        float max_value;

        if (count == 0) return;

        max_value = min_value = fn(offset);
        for (i = 0; i < count; ++i)
        {
            float value = fn(i + offset);
            min_value = min(value, min_value);
            max_value = max(value, max_value);
        }

        if (nk_chart_begin(&ctx, type, count, min_value, max_value))
        {
            for (i = 0; i < count; ++i)
                nk_chart_push(&ctx, fn(i + offset));
            nk_chart_end(&ctx);
        }
    }

    int popupBegin(nk_popup_type type, const(char)* title, nk_flags flags, nk_rect bounds)
    {
        return nk_popup_begin(&ctx, type, title, flags, bounds);
    }

    void popupClose()
    {
        nk_popup_close(&ctx);
    }

    void popupEnd()
    {
        nk_popup_end(&ctx);
    }

    int combo(const(char)** items, int count, int selected, int item_height, nk_vec2 size)
    {
        return nk_combo(&ctx, items, count, selected, item_height, size);
    }

    int comboSeparator(const(char)* items_separated_by_separator, int separator, int selected, int count, int item_height, nk_vec2 size)
    {
        return nk_combo_separator(&ctx, items_separated_by_separator, separator, selected, count, item_height, size);
    }

    int comboString(const(char)* items_separated_by_zeros, int selected, int count, int item_height, nk_vec2 size)
    {
        return nk_combo_string(&ctx, items_separated_by_zeros, selected, count, item_height, size);
    }

    /*int comboCallback(void func(void*, int, const(char) **) fn, void *userdata, int selected, int count, int item_height, nk_vec2 size)
    {
    return nk_combo_callback(&ctx, fn, userdata, selected, count, item_height, size);
    }*/

    void combobox(const(char)** items, int count, int* selected, int item_height, nk_vec2 size)
    {
        nk_combobox(&ctx, items, count, selected, item_height, size);
    }

    void comboboxString(const(char)* items_separated_by_zeros, int* selected, int count, int item_height, nk_vec2 size)
    {
        nk_combobox_string(&ctx, items_separated_by_zeros, selected, count, item_height, size);
    }

    void comboboxSeparator(const(char)* items_separated_by_separator, int separator, int* selected, int count, int item_height, nk_vec2 size)
    {
        nk_combobox_separator(&ctx, items_separated_by_separator, separator, selected, count, item_height, size);
    }

    /*void comboboxCallback(void function(void*, int, const(char) **), void*, int *selected, int count, int item_height, nk_vec2 size)
    {
    nk_combobox_callback(&ctx);
    }*/
    
    int comboBeginText(const(char)* selected, int len, nk_vec2 size)
    {
        return nk_combo_begin_text(&ctx, selected, len, size);
    }

    int comboBeginLabel(const(char)* selected, nk_vec2 size)
    {
        return nk_combo_begin_label(&ctx, selected, size);
    }

    int comboBeginColor(nk_color color, nk_vec2 size)
    {
        return nk_combo_begin_color(&ctx, color, size);
    }

    int comboBeginSymbol(nk_symbol_type type, nk_vec2 size)
    {
        return nk_combo_begin_symbol(&ctx, type, size);
    }

    int comboBeginSymbolLabel(const(char)* selected, nk_symbol_type type, nk_vec2 size)
    {
        return nk_combo_begin_symbol_label(&ctx, selected, type, size);
    }

    int comboBeginSymbolText(const(char)* selected, int len, nk_symbol_type type, nk_vec2 size)
    {
        return nk_combo_begin_symbol_text(&ctx, selected, len, type, size);
    }

    int comboBeginImage(nk_image img, nk_vec2 size)
    {
        return nk_combo_begin_image(&ctx, img, size);
    }

    int comboBeginImageLabel(const(char)* selected, nk_image img, nk_vec2 size)
    {
        return nk_combo_begin_image_label(&ctx, selected, img, size);
    }

    int comboBeginImageText(const(char)* selected, int len, nk_image img, nk_vec2 size)
    {
        return nk_combo_begin_image_text(&ctx, selected, len, img, size);
    }

    int comboItemLabel(const(char)* label, nk_flags align_ment)
    {
        return nk_combo_item_label(&ctx, label, align_ment);
    }

    int comboItemText(const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_combo_item_text(&ctx, txt, len, align_ment);
    }

    int comboItemImageLabel(nk_image img, const(char)* label, nk_flags align_ment)
    {
        return nk_combo_item_image_label(&ctx, img, label, align_ment);
    }

    int comboItemImageText(nk_image img, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_combo_item_image_text(&ctx, img, txt, len, align_ment);
    }

    int comboItemSymbolLabel(nk_symbol_type type, const(char)* label, nk_flags align_ment)
    {
        return nk_combo_item_symbol_label(&ctx, type, label, align_ment);
    }

    int comboItemSymbolText(nk_symbol_type type, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_combo_item_symbol_text(&ctx, type, txt, len, align_ment);
    }

    void comboClose()
    {
        nk_combo_close(&ctx);
    }

    void comboEnd()
    {
        nk_combo_end(&ctx);
    }

    int contextualBegin(nk_flags flags, nk_vec2 size, nk_rect trigger_bounds)
    {
        return nk_contextual_begin(&ctx, flags, size, trigger_bounds);
    }

    int contextualItemText(const(char)* txt, int len, nk_flags align_)
    {
        return nk_contextual_item_text(&ctx, txt, len, align_);
    }

    int contextualItemLabel(const(char)* label, nk_flags align_)
    {
        return nk_contextual_item_label(&ctx, label, align_);
    }

    int contextualItemImageLabel(nk_image img, const(char)* label, nk_flags align_ment)
    {
        return nk_contextual_item_image_label(&ctx, img, label, align_ment);
    }

    int contextualItemImageText(nk_image img, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_contextual_item_image_text(&ctx, img, txt, len, align_ment);
    }

    int contextualItemSymbolLabel(nk_symbol_type type, const(char)* label, nk_flags align_ment)
    {
        return nk_contextual_item_symbol_label(&ctx, type, label, align_ment);
    }

    int contextualItemSymbolText(nk_symbol_type type, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_contextual_item_symbol_text(&ctx, type, txt, len, align_ment);
    }

    void contextualClose()
    {
        nk_contextual_close(&ctx);
    }

    void contextualEnd()
    {
        nk_contextual_end(&ctx);
    }

    void tooltip(const(char)* txt)
    {
        nk_tooltip(&ctx, txt);
    }

    /*void tooltipf(const(char)*, ...)
    {
    nk_tooltipf(&ctx);
    }

    void tooltipfv(const(char)*, va_list)
    {
    nk_tooltipfv(&ctx);
    }*/
    
    int tooltipBegin(float width)
    {
        return nk_tooltip_begin(&ctx, width);
    }

    void tooltipEnd()
    {
        nk_tooltip_end(&ctx);
    }

    void menubarBegin()
    {
        nk_menubar_begin(&ctx);
    }

    void menubarEnd()
    {
        nk_menubar_end(&ctx);
    }

    int menuBeginText(const(char)* title, int title_len, nk_flags align_, nk_vec2 size)
    {
        return nk_menu_begin_text(&ctx, title, title_len, align_, size);
    }

    int menuBeginLabel(const(char)* label, nk_flags align_, nk_vec2 size)
    {
        return nk_menu_begin_label(&ctx, label, align_, size);
    }

    int menuBeginImage(const(char)* label, nk_image img, nk_vec2 size)
    {
        return nk_menu_begin_image(&ctx, label, img, size);
    }

    int menuBeginImageText(const(char)* txt, int len, nk_flags align_, nk_image img, nk_vec2 size)
    {
        return nk_menu_begin_image_text(&ctx, txt, len, align_, img, size);
    }

    int menuBeginImageLabel(const(char)* label, nk_flags align_, nk_image img, nk_vec2 size)
    {
        return nk_menu_begin_image_label(&ctx, label, align_, img, size);
    }

    int menuBeginSymbol(const(char)* label, nk_symbol_type type, nk_vec2 size)
    {
        return nk_menu_begin_symbol(&ctx, label, type, size);
    }

    int menuBeginSymbolText(const(char)* txt, int len, nk_flags align_, nk_symbol_type type, nk_vec2 size)
    {
        return nk_menu_begin_symbol_text(&ctx, txt, len, align_, type, size);
    }

    int menuBeginSymbolLabel(const(char)* label, nk_flags align_, nk_symbol_type type, nk_vec2 size)
    {
        return nk_menu_begin_symbol_label(&ctx, label, align_, type, size);
    }

    int menuItemText(const(char)* txt, int len, nk_flags align_)
    {
        return nk_menu_item_text(&ctx, txt, len, align_);
    }

    int menuItemLabel(const(char)* label, nk_flags align_ment)
    {
        return nk_menu_item_label(&ctx, label, align_ment);
    }

    int menuItemImageLabel(nk_image img, const(char)* label, nk_flags align_ment)
    {
        return nk_menu_item_image_label(&ctx, img, label, align_ment);
    }

    int menuItemImageText(nk_image img, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_menu_item_image_text(&ctx, img, txt, len, align_ment);
    }

    int menuItemSymbolText(nk_symbol_type type, const(char)* txt, int len, nk_flags align_ment)
    {
        return nk_menu_item_symbol_text(&ctx, type, txt, len, align_ment);
    }

    int menuItemSymbolLabel(nk_symbol_type type, const(char)* label, nk_flags align_ment)
    {
        return nk_menu_item_symbol_label(&ctx, type, label, align_ment);
    }

    void menuClose()
    {
        nk_menu_close(&ctx);
    }

    void menuEnd()
    {
        nk_menu_end(&ctx);
    }

    void styleDefault()
    {
        nk_style_default(&ctx);
    }

    void styleFromTable(const(nk_color)* colors)
    {
        nk_style_from_table(&ctx, colors);
    }

    void styleLoadCursor(nk_style_cursor cursor, const(nk_cursor)* c)
    {
        nk_style_load_cursor(&ctx, cursor, c);
    }
    
    void styleLoadAllCursors(nk_cursor* cursor)
    {
        nk_style_load_all_cursors(&ctx, cursor);
    }

    void styleSetFont(const(nk_user_font)* font)
    {
        nk_style_set_font(&ctx, font);
    }

    int styleSetCursor(nk_style_cursor cursor)
    {
        return nk_style_set_cursor(&ctx, cursor);
    }

    void styleShowCursor()
    {
        nk_style_show_cursor(&ctx);
    }

    void styleHideCursor()
    {
        nk_style_hide_cursor(&ctx);
    }

    int stylePushFont(const(nk_user_font)* font)
    {
        return nk_style_push_font(&ctx, font);
    }

    int stylePushFloat(float* address, float value)
    {
        return nk_style_push_float(&ctx, address, value);
    }

    int stylePushVec2(nk_vec2* address, nk_vec2 value)
    {
        return nk_style_push_vec2(&ctx, address, value);
    }

    int stylePushStyleItem(nk_style_item* address, nk_style_item value)
    {
        return nk_style_push_style_item(&ctx, address, value);
    }

    int stylePushFlags(nk_flags* address, nk_flags value)
    {
        return nk_style_push_flags(&ctx, address, value);
    }

    int stylePushColor(nk_color* address, nk_color value)
    {
        return nk_style_push_color(&ctx, address, value);
    }
    
    int stylePopFont()
    {
        return nk_style_pop_font(&ctx);
    }

    int stylePopFloat()
    {
        return nk_style_pop_float(&ctx);
    }

    int stylePopVec2()
    {
        return nk_style_pop_vec2(&ctx);
    }

    int stylePopStyleItem()
    {
        return nk_style_pop_style_item(&ctx);
    }

    int stylePopFlags()
    {
        return nk_style_pop_flags(&ctx);
    }

    int stylePopColor()
    {
        return nk_style_pop_color(&ctx);
    }
}
